start = dictionary # dictionary metadata in TEI header

dictionary = element dictionary {taxonomy, entry+} # reference to taxonomy and entries

taxonomy = attribute taxonomy{string} # the taxonomy is defined in taxonomy.rng

entry = element entry {
    attribute entryId {xsd:ID}, # unique ID for the entry
    element lemma {xsd:string}, # the normalized form
    # the following three are a synopsis of information from the meaninggroup(s)
    # TODO: to generally follow TEI, we can put the following information into this structure:
    # form (including orth, phoneticVariants), gramGrp (pos), def (hierarchizedMeanings = senses) 
    morphology,
    element relativeFrequency {xsd:int}, # from corpus, per 100,000
    element occurrences {list {xsd:string+}}, # union of sense:occurrences
    element phoneticVariants: {list {variant}}, # union of phonti
    element orthographicVariants: {list {variant}}, # union of phonti

    hierarchizedMeanings,     
    internalReferences?,
    etymology?,
    biblioEntry?, # pointer(s) to bibliography (optional)
    comment?,

    attribute stage {"inprogress"|"finished"},
    attribute DOI {xsd:anyURI},
}

morphology = element morphology {
    compositionType? {"simplex"|"derived"|"compound"|"derived compoun"}?,
    pos {list {xsd:string+}}  # union of POS (from corpus)
}


hierarchizedMeanings = element hierarchizedMeanings { # one per entry
    meaninggroup+
}
    
meaninggroup = element meaninggroup { # one or more
    attribute serialId {xsd:int}, # internal numbering
    element label? {xsd:string}, # the title of the meaning group
    element semantics {list {semantic}} # an ordered list
}
    
semantic = element semantic {
    attribute serialId {xsd:int}, # internal numbering
    element morphology {xsd:string}, # POS
    element sense {xsd:string}, # in the case of term. tech., its definition
    element definition? {xsd:string}, # detailed description of the use of the lexeme
    element semanticDomain {list{xsd:string+}}, # reference to taxonomy
    element termTech?,
    element mwes* {list {mwe}},
    element examples {list{example}}, # references to tokens in corpus
    element occurrences {list{xsd:string+}}, # references to tokens in corpus
    element morphologicalForms {list {morphologicalForm}}
}

form = element morphologicalForm {
    element feats {list{xsd:string}},
    element phoneticVariants {list {variant}},
    element orthographicVariants* {list {variant}}
}

variant = element variant {
    attribute type? {"phonetic"|"heterographic"},
    element form {xsd:string},
    element frequency {xsd:int},
    element occurrences? {list{xsd:string+}}

}

mwe = element mwe {
    attribute serialId {xsd:int}, # internal numbering
    element label {xsd:string+},
    element literalTranslation? {xsd:string+},
    element sense {xsd:string}, # in the case of term. tech., its definition
    element termTech?,
    element examples? {list{example}},
    element occurrences? {list{xsd:string+}}, # references to tokens in corpus
}

termTech = element terminusTechnicus {
    attribute category {"astr"|"bot"|"econom"|"legal"|"measure"|"med"|"philos"|"pol"|"purity"|"ritual"|"theol"|"zool"}, 
    element literalTranslation? {xsd:string}, # the literal translation of the term. tech., its definition will be stored in semantics.definition 
    element definition {xsd:string}
}

example = element example { # selected examples from corpus
    attribute sentenceId {xsd:string},
    element sentenceText {xsd:string}, # from corpus
    element sentenceTranslation # from corpus
}

# optional additional information:
internalReferences = element internalReferences {iRef+}

iRef = element iRef {
    attribute type {"synonym"|"antonym"|"homonym"|"base"|"prefix"|"suffix"}, # "constituent" is generated automatically based on "base"
    element refId {xsd:entryID}
}

# optional references to other dictionaries
externalReferences = element externalReferences {eRef+}

etymology = element etymology {
    attribute type {"inheritedFrom"|"originOf"|"loanWordFrom"|"loanWordIn"|"loanTranslationFrom"|"cognate"}
    element language {xsd:string},
    element lexeme {xsd:string},
    comment?
}

biblioEntry = element biblioEntry {
    attribute type {"writing"|"grammar"|"sense"|"etymology"},
    element senseId? {xsd:ID}, # serialId of sense
    element bibRef {xsd:string} 

} # list of pointers to the bibliographic database
comment = element comment {text}
