start = dictionary # dictionary metadata in TEI header

dictionary = element dictionary {taxonomy, entry+} # reference to taxonomy and entries

taxonomy = attribute taxonomy {string} # the taxonomy is defined in taxonomy.rng

entry = element entry {
    attribute entryId {xsd:ID}, # unique ID for the entry
    element lemma {xsd:string}, # the normalized form
    element language {xsd:string}, # ISO 639-2 three-letter code
    # We use corssRef for linking different lemmata to one entry,
    # for example different forms/readings of one lemma
    attribute crossRef {xsd:IDREF}, # if the entry is a cross reference the other elements will be empty
        
    # TODO: to generally follow TEI, we can put the following information into this structure:
    # form (including orth, forms), gramGrp (pos), def (hierarchizedMeanings = senses) 
    morphology, # different components shown in different locations, see infra
    timeline, # shows the frequency of the occurrences of the lemma in different cent.
    element relativeFrequency {xsd:int}, # from corpus, per 100,000

    element forms {list {variant}}, # attested types in the corpus linked to the lemma 
    element orthographicVariants {list {variant}}, # union of transliterations
    element occurrences {list{attestation}},

    hierarchizedMeanings,     
    
    internalReferences?,
    equivalents?,
    etymology?,
    biblioEntry?,
    comment?,

    attribute stage {"inprogress" | "finished" | "published"},
    attribute DOI {xsd:anyURI},
}

morphology = element morphology {
    element pos {list {xsd:string+}}  # union of POS (from corpus), shown after the lemma
    element compositionType? {"simplex" | "derived" | "compound" | "derivedCompound"}?, # shown after the lemma
    element composition? {xsd:string}, # the morphological analysis of a compound or a derived word
    # independent of the existence of its constituents in the corpus, e.g. abāyišnīg > abāy-išn-īg; 
    # same level as lemma, but listed in internal references
}

# In which centuries a lemma is attested can be retrieved from the metadata of the texts,
# in which the lemma is attested
timeline = element timeline {
    attribute century {xsd:int},
    attribute freq {xsd:int} # frequency of the tokens linked to the lemma in the century
}

hierarchizedMeanings = element hierarchizedMeanings { # one per entry
    meaningGroup+
}
    
meaningGroup = element meaningGroup { # one or more
    attribute serialId {xsd:int}, # internal numbering
    element label? {xsd:string}, # an optional label for the meaning group
    element semantics {list {semantic}} # an ordered list
}
    
semantic = element semantic {
    attribute serialId {xsd:int}, # internal numbering
    element morphology {xsd:string}, # POS

    semanticCore,
    
    element morphologicalForms {list {morphologicalForm}},
    element mwes* {list {mwe}} # alphabetic sorted
}

semanticCore = element semanticCore {
    element sense {xsd:string}, # in the case of term. tech. = its definition

    # explanation may include detailed description of the use of the lexeme,
    # reasons for transcription, prototypical examples
    element explanation? {xsd:string},

    element semanticDomain? {list{concept}}, # reference to taxonomy
    element termTech?,

    # we decided to eliminate examples
    # element examples? {list{example}}, # some examples for this sense of the lemma
    element occurrences {list{attestation}},
}

form = element morphologicalForm {
    element feats {list{xsd:string}}, # POS features
    element forms {list {variant}},
    element orthographicVariants* {list {variant}}
}

variant = element variant {
    attribute script? {"Pahlavi" | "Pazand" | "Inscription" | "Manichean" | "Psalm"| "Arabic"},
    	# the script in which the token is written; lemma language dependent
    attribute type? {"phonetic" | "heterographic"},
    element form {xsd:string},
    element frequency {xsd:int},
    element occurrences? {list{attestation}}

}

mwe = element mwe {
    attribute serialId {xsd:int}, # internal numbering
    element label {xsd:string+}, # MP phrase
    element literalTranslation? {xsd:string+},

    semanticCore
}

concept = element concept {
    element taxonomyID {xsd:string+}, # this gives us the possiblity to give ref. to different taxonomies
    element conceptID {xsd:IDREF}
}

attestation = element attestation  {
    element tokenId {xsd:IDREF},
    element uncertain {xsd:boolean} # true if token.uncertain = reading or sense
}

termTech = element terminusTechnicus {
    attribute category {"astr" | "bot" | "econom" | "legal" | "measure" | "med" | "philos" | 
    			"pol" | "purity" | "ritual" | "theol" | "zool"}, 
    element literalTranslation? {xsd:string},
    # the literal translation of the term. tech., its definition will be shown in semantics.definition 
    element definition {xsd:string}
}

# example = element example { # selected examples from corpus
#     attribute sentenceId {xsd:string},
#     element sentenceText {xsd:string}, # from corpus
#     element sentenceTranslation # from corpus
# }

# optional additional information:
internalReferences = element internalReferences {iRef+}

iRef = element iRef {
    attribute type {"synonym" | "antonym" | "homonym" | "constituent" | "prefix" | "suffix"},
    # "constituent of" is generated automatically based on "constituent",
    # e.g. for a-sar-rōšnīh we have constituent = a, sar, rōšnīh.
    # From all of these lemmata, we have a link to a-sar-rōšnīh.
    element refId {xsd:IDREF} # ref to another entry
}


equivalents = element equivalents {
    # from token.Avestan of all tokens linked to the lemma
    element avEquivalents {list{xsd:string}},
    element mpTranslations {list{xsd:string}}, # MP translations of all Av. equivalents
    # a) Send every avEquivalents from the first list to CAB to receive their lemmata
    # b) Retrieve the conjugated/declinated forms of every Av. lemma from CAB
    # c) Find the lemmata of all MP tokens translating these Av. forms in MPCD corpus
}

etymology = element etymology {
    attribute type {"protoForm" | "cognate" | "loanWordFrom" | "loanWordIn" | 
			"loanTranslationFrom"}
    element language {xsd:string}, 
    element lexeme {xsd:string},
    element url? {xsd:anyURI},
    comment?
}

biblioEntry = element biblioEntry {
    attribute type {"writing" | "grammar" | "sense" | "etymology"},
    element senseId? {xsd:ID}, # serialId of sense
    element bibRef {xsd:string} # ref to the bibliographic database
} 
comment = element comment {text}
